# USE-000: Registration server
The registration server behavior will be:

1. Ask for a long url 
1. `[USE-000-00]` Check if the long url is already on
the database 
1. `[USE-000-01]` If not, generate a short url.
1. Register the url.
1. `[USE-000-02]` If the long url already exists,return a message accordingly


## USE-000-00: Check for url if already on the database
For this use case, we will assume the following:

+ The database is properly synchronized by an external tool 
+ Database servers are synchronized using *consistent hashing*

For testing purpouses, I will create an extra service `[USE-007]` that syncs
everything using brute force.

Checking for an already registered url will only search on the current node's
database.

For url search, refer to `[TECH-001]`

## USE-000-01: Generate a short url
Given a long url $lg$ The generation of a short url $sg$ will be done using
CRC64 and base64 for safe url encoding. The algorithms is defined as 

$$
sg = (crc64 \circ base64)(lg)
$$

Base64 is also not safe because it could output the slash (`/`) and plus (`+`)
character that will break the url. Such characters will be replaced with 
underscore (`_`), and dash (`-`) respectivelly. The full $sg$ equation is

$$
sg = (replace \circ base64 \circ crc64)(lg)
$$

where $replace$ is the function that replaces the undesired characters.

The usage of the base64 encoding will give us a length of 10 characters total,
or more specifically:

$$
\begin{aligned} 
2^{64} & = 64^x \\
x & = 64/log_2(64) \\
x & = 10\\
\end{aligned}
$$

This combination is choosed to keep this prototype fast and simple. If a
different length is required, other hashing algorithms can be used such as
MD5, Tiger, or SHA. However, it may require a coding mechanism for shortening
the hash output to accomodate the desired length.

*NOTE*: A proper solution for production will implement base64 instead to avoid extra
collisions.

### Collisions
In order to avoid short url collisions, I will implement `linear probing`. 
On `linear probing`, each key is defined as a location. When attempting to 
insert a new register, if the location is already used, the algorithm will
search on adyacent locations for an empty one.

I will implement linear probing as follows: If a generated key $sg_i$ is already
in use, a new $sg_{i+1}$ key will be generated by increasing the crc64 output
by one as follows

$$ 
\begin{aligned}
sg_0 & = (replace \circ base64 \circ crc64)(lg) \\
sg_{i+1} & = (replace \circ base64 \circ add(i+1) \circ crc64)(lg)
\end{aligned}
$$

Where $add(i+1)$ is a curried function defined as:

$$
add(x, y) = x + y
$$

Notice that this extra operation will lead into longer short urls than 10
characters in the long run.

### Weakness
The generation service will have the following weaknesses:

+ It doesn't handle short url collision with other servers
+ It's only effective for $2^{64}$ long urls, after that, the service will
generate longer urls. For this prototype, the add function will be redefined as

$$
add(x, y) = x + y\quad (\textrm{mod}\quad 2^{64})
$$

*Note:* Fixing collision can be done using other algorithms such as `rehashing`
or `overflow chaning` which allow for better key distribution. However, such 
algorithms also introduce new techincal requirements outside of the scope of
this prototype.

## USE-000-02 Error message
If the long url was already registered on the database, the registration service
will return an error message with the following description:

    ERR-000-02-00: URL already registered
